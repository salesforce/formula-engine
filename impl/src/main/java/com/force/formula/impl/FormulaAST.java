/*
 * Created on Dec 28, 2004
 *
 */
package com.force.formula.impl;

import antlr.CommonAST;
import antlr.Token;
import antlr.collections.AST;
import com.force.formula.parser.gen.SfdcFormulaTokenTypes;

import java.lang.reflect.Type;
import java.util.LinkedList;
import java.util.List;

import com.force.formula.FormulaDataType;

/**
 * AST for formula evaluation
 *
 * @author dchasman
 * @since 140
 */
public class FormulaAST extends CommonAST {

    private static final long serialVersionUID = 1L;
	public FormulaAST() {
        super();
    }

    public FormulaAST(String token) {
        super();
        setText(token);
    }

    public Type getDataType() {
        return dataType;
    }

    public void setDataType(Type dataType) {
        this.dataType = dataType;
    }

    public FormulaAST getParent() {
        return parent;
    }

    public FormulaAST replace(FormulaAST newNode) {
        FormulaAST currentChild = (FormulaAST)parent.getFirstChild();
        FormulaAST previousChild = null;
        while (currentChild != null) {
            if (currentChild == this) {
                if (previousChild != null)
                    previousChild.setNextSibling(newNode);
                else
                    parent.setFirstChild(newNode);

                newNode.setParent(parent);
                newNode.setNextSibling(currentChild.getNextSibling());
                // cleanup this (not strictly needed)
                currentChild.setParent(null);
                currentChild.setNextSibling(null);

                return newNode;
            }
            previousChild = currentChild;
            currentChild = (FormulaAST)currentChild.getNextSibling();
        }
        return this;
    }

    public void reparent(FormulaAST newParent) {
        reparent(newParent, null);
    }

    public void reparent(FormulaAST newParent, FormulaAST newSibling) {
        FormulaAST currentParent = parent;

        if (currentParent != null) {
            // Wire up new parent child relationship
            List<FormulaAST> children = new LinkedList<FormulaAST>();
            FormulaAST currentChild = (FormulaAST)currentParent.getFirstChild();
            while (currentChild != null) {
                children.add((currentChild != this) ? currentChild : newParent);
                currentChild = (FormulaAST)currentChild.getNextSibling();
            }

            currentParent.removeChildren();

            //TODO(arman): this is O(n^2) operation!
            for (FormulaAST childToAdd : children) {
                childToAdd.setNextSibling(null);
                currentParent.addChild(childToAdd);
            }
        }

        this.setNextSibling(null);
        newParent.addChild(this);

        if (parent.getToken() == null) {
            // Inherit the token of the child node (autogenerated/implicit wrapper parent node)
            parent.setToken(getToken());
        }

        if (newSibling != null) {
            newSibling.setNextSibling(null);
            newParent.addChild(newSibling);
        }
    }

    @Override
    public void addChild(AST child) {
        super.addChild(child);
        setParentToThis(child);
    }

    @Override
    public void removeChildren() {
        // Set the parent to null to remove reference to this
        FormulaAST child = (FormulaAST)getFirstChild();
        while (child != null) {
            child.parent = null;
            child = (FormulaAST)child.getNextSibling();
        }

        super.removeChildren();
    }

    @Override
    public void setFirstChild(AST child) {
        super.setFirstChild(child);
        setParentToThis(child);
    }

    @Override
    public void setNextSibling(AST sibling) {
        super.setNextSibling(sibling);

        // Siblings must all have the same parent
        if (sibling != null)
            ((FormulaAST)sibling).parent = this.parent;
    }

    public FormulaDataType getColumnType() {
        return this.columnType;
    }

    public void setColumnType(FormulaDataType columnType) {
        this.columnType = columnType;
    }

    public Token getToken() {
        return token;
    }

    public void setToken(Token token) {
        this.token = token;
    }

    public void setParent(FormulaAST parent) {
        this.parent = parent;
    }

    public static boolean isTopOfTemplateExpression(FormulaAST node) {
        FormulaAST parent = node.getParent();
        if (isFunctionNode(parent, "template")) {
            return true;
        }

        // Check the specific grandparent case of template(nullvalue(fieldref, "substitution text")) to support template null value substitution
        FormulaAST grandparent = parent.getParent();
        FormulaAST nextSibling = (FormulaAST)node.getNextSibling();
        return (isFunctionNode(grandparent, "template") && isFunctionNode(parent, "nullvalue") &&
                 nextSibling != null && nextSibling.token != null && nextSibling.token.getType() == SfdcFormulaTokenTypes.STRING_LITERAL);
    }

    public static boolean isFunctionNode(FormulaAST node, String function) {
        if (node == null) {
            return false;
        }

        return ((node.getType() == SfdcFormulaTokenTypes.FUNCTION_CALL && node.getText().equalsIgnoreCase(function)));
    }

    public static boolean isTopOfReferenceFormula(FormulaAST node) {
        FormulaAST parent = node.getParent();
        return parent.getType() == SfdcFormulaTokenTypes.DYNAMIC_REF_ROOT;
    }

    public boolean isLiteral() {
        switch(getType()) {
        case SfdcFormulaTokenTypes.TRUE:
            return true;
        case SfdcFormulaTokenTypes.FALSE:
            return true;
        case SfdcFormulaTokenTypes.NUMBER:
            return true;
        case SfdcFormulaTokenTypes.NULL:
            return true;
        case SfdcFormulaTokenTypes.STRING_LITERAL:
            return true;
        default:
            return false;
        }
    }

    public boolean isConstantExpression() {
        return isConstant;
    }

    public void setConstantExpression(boolean val) {
        isConstant = val;
    }

    public boolean canBeNull() {
        return canBeNull;
    }

    public void setCanBeNull(boolean val) {
        canBeNull = val;
    }

    public boolean isDynamicReferenceBase() {
        // a[b] : a is dynamic ref base;  or a[b].c  a[b] is dynamic ref base
        return parent != null && parent.getType() == SfdcFormulaTokenTypes.DYNAMIC_REF && parent.down == this
          || this.getType() == SfdcFormulaTokenTypes.DYNAMIC_REF && this.right != null && this.right.getType() == SfdcFormulaTokenTypes.DYNAMIC_REF_IDENT;
    }

    private void setParentToThis(AST child) {
        if (child == null)
            return;

        ((FormulaAST)child).parent = this;
    }

    private Type dataType;
    private FormulaDataType columnType;
    private FormulaAST parent;
    private Token token;
    private boolean isConstant = false;
    private boolean canBeNull = true;
}
